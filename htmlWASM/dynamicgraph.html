<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Graphviz Example with Faceted Navigation</title>
 <style>
    :root {
      --primary-color: #acf9e9;
      --secondary-color: #809294;
      --background-color: #dde3e3;
      --text-color: #333333;
      --border-color: #333d3e;
      --hover-color: #809294;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      margin: 0;
      padding: 0;
      background-color: var(--background-color);
      color: var(--text-color);
    }

    #page-container {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      width: 100%;
      margin: 0 auto;
      padding: 20px;
    }

    #dot-src-container {
      width: 100%;
      margin-bottom: 20px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 20px;
    }

   #main-container {
      display: flex;
      align-items: flex-start;
      width: 100%;
      gap: 20px;
      overflow: hidden; /* Prevent scrollbars on the main container */
    }

    #faceted-navigation {
      width: 280px;
      flex-shrink: 0; /* Prevent the navigation from shrinking */
      display: flex;
      flex-direction: column;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 20px;
      max-height: calc(100vh - 100px); /* Adjust based on your layout */
      overflow-y: auto; /* Allow scrolling in the navigation if needed */
    }

    /* SVG container on the right */
      #svg-container {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 20px;
      overflow: hidden;
    }

    #graph-container {
      flex-grow: 1;
      width: 100%;
      height: 100%;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #graph-container svg {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
    }

    textarea {
      width: 100%;
      height: 200px;
      resize: vertical;
      border-radius: 8px;
      padding: 12px;
      border: 1px solid var(--border-color);
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
    }

    .scroll-container {
      flex-grow: 1;
      overflow-y: auto;
      margin-bottom: 15px;
    }

    #clusters-list, #classes-list {
      margin-bottom: 15px;
    }

    button {
      border-radius: 8px;
      padding: 10px 16px;
      font-size: 14px;
      cursor: pointer;
      background-color: var(--primary-color);
      color: var(--text-color);
      border: none;
      transition: background-color 0.3s, transform 0.1s;
    }

    button:hover {
      background-color: var(--hover-color);
    }

    button:active {
      transform: translateY(1px);
    }

    .button-large {
      height: 44px;
      padding: 0 24px;
      font-size: 16px;
    }

    .button-icon-left {
      padding-left: 12px;
    }

    .button-icon-right {
      padding-right: 12px;
    }

    .button-icon-both {
      padding-left: 12px;
      padding-right: 12px;
    }

    .slider-container {
      width: 100%;
      margin-top: 15px;
    }

    .slider {
      -webkit-appearance: none;
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: #d7dcdf;
      outline: none;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--secondary-color);
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--secondary-color);
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .slider:hover::-webkit-slider-thumb,
    .slider:hover::-moz-range-thumb {
      background-color: var(--hover-color);
    }

    .cluster { cursor: pointer; }
    .cluster:hover { opacity: 0.8; }
    .cluster-collapsed { stroke-width: 2px; stroke-dasharray: 5, 5; }
    .node { cursor: pointer; }
    .node ellipse, .node polygon, .node rect { transition: all 0.3s ease-in-out; }

    #file-input-container, #property-selector-container {
      margin-bottom: 20px;
    }

    .property-selector {
      border: 1px solid var(--border-color);
      padding: 15px;
      margin-top: 15px;
      border-radius: 8px;
      background-color: white;
    }

    .property-selector label {
      display: block;
      margin-bottom: 8px;
    }

    #file-based-graph-container {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      gap: 20px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
    }

    .file-input-container {
      flex: 1 1 auto;
      min-width: 200px;
      text-align: center;
    }

    .file-input-header {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
      color: var(--primary-color);
    }

    #generate-graph {
      flex-basis: 100%;
      margin-top: 20px;
    }

    #property-selector-container {
      flex-basis: 100%;
    }

    #context-menu {
      position: fixed;
      z-index: 10000;
      background: white;
      border: 1px solid var(--border-color);
      padding: 8px;
      display: none;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    #context-menu ul {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }

    #context-menu li {
      padding: 8px 12px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    #context-menu li:hover {
      background-color: var(--hover-color);
    }

    h3 {
      color: var(--primary-color);
      border-bottom: 2px solid var(--border-color);
      padding-bottom: 8px;
      margin-top: 0;
    }

    #toggle-file-based-graph {
      background-color: var(--primary-color);
      border: none;
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s;
      margin-bottom: 15px;
    }

    
    input[type="file"] {
      display: none;
    }

    .file-input-label {
      display: inline-block;
      padding: 8px 12px;
      background-color: var(--primary-color);
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .file-input-label:hover {
      background-color: var(--hover-color);
    }

    .file-name {
      margin-top: 8px;
      font-size: 12px;
      color: #666;
    }
  </style>
</head>
<body>
  <div id="page-container">
    <button id="toggle-file-based-graph">File Based Graph â–¼</button>
    <div id="file-based-graph-container" style="display: none;">
      <div class="file-input-container">
        <span class="file-input-header">Nodes</span>
        <label for="component-file" class="file-input-label">Choose File</label>
        <input type="file" id="component-file" accept=".csv" />
        <div class="file-name" id="component-file-name">No file chosen</div>
      </div>
      <div class="file-input-container">
        <span class="file-input-header">Edges</span>
        <label for="relation-file" class="file-input-label">Choose File</label>
        <input type="file" id="relation-file" accept=".csv" />
        <div class="file-name" id="relation-file-name">No file chosen</div>
      </div>
      <div class="file-input-container">
        <span class="file-input-header">Style</span>
        <label for="style-file" class="file-input-label">Choose File</label>
        <input type="file" id="style-file" accept=".txt" />
        <div class="file-name" id="style-file-name">No file chosen</div>
      </div>
      <button id="generate-graph" class="button-large">Load files</button>
      <div id="property-selector-container"></div>
    </div>

    <div id="dot-src-container">
      <textarea id="dot-src" spellcheck="false">
        
                digraph G {
          subgraph cluster_0 {
            style=filled;
			class="a-side 2000";
            color=lightgrey;
            node [style=filled,color=white];
            a0 -> a1 -> a2 -> a3;
            label = "Cluster 0";
			a0 [class="somenodes"];
			a3 [class="somenodes"];

            subgraph cluster_0_1 {
			  class="a-side 2003";
              style=filled;
              color=lightblue;
              node [style=filled,color=white];
              a0_1 -> a1_1 -> a2_1 -> a3_1;
              label = "Cluster 0_1";
            }
          }

          subgraph cluster_1 {
            class="b-side 2005";
            node [style=filled];
            b0 -> b1 -> b2 -> b3;
            label = "Cluster 1";
            color=blue;

            subgraph cluster_1_1 {
              class="b-side 2008";
              style=filled;
              color=lightblue;
              node [style=filled,color=white];
              b0_1 -> b1_1 -> b2_1 -> b3_1;
              label = "Cluster 1_1";
			  
            }
          }

          start -> a0;
          start -> b0;
          a1 -> b3[class="crosscluster"];
          b2 -> a3[class="crosscluster"];
          a3 -> a0;
          a3 -> end;
          b3 -> end;
          a0_1 -> b0_1 [class="crosscluster"];
          start [shape=Mdiamond, fillcolor="white", color="black"];
          end [shape=Msquare, fillcolor="white", color="black"];
        }
      </textarea>
      <button id="update-dot-src" class="button-large">Update/Reset Graph</button>
      <p>Click on Nodes to highlight/unhighlight connected edges, click on clusters to collapse/expand.</p>
    </div>
    
    <div id="main-container">
      <div id="faceted-navigation">
        <button id="apply-filter-button" class="button-large">Apply Filter</button>
        <h3>Expand/Collapse Clusters</h3>
        <div class="scroll-container">
          <div id="clusters-list"></div>
        </div>
        <h3>Hide/Highlight</h3>
        <div class="scroll-container">
          <div id="numerical-classes-list"></div>
        </div>
        <h3>Hide/Highlight Categories</h3>
        <div class="scroll-container">
          <div id="alphanumeric-classes-list"></div>
        </div>
      </div>
      <div id="svg-container">
        <div id="graph-container"></div>
      </div>
    </div>
    <div id="context-menu">
      <ul>
        <li id="highlight-node">Highlight Connected Edges</li>
        <li id="filter-graph">Filter Graph</li>
      </ul>
    </div>
  </div>






<script type="module">
  import "https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.4/dist/graphlib-dot.js";
  import { Graphviz } from "https://cdn.jsdelivr.net/npm/@hpcc-js/wasm/dist/graphviz.js";
 
  let graph;
  let graphviz;
  let originalGraph;
  let initialDotSrc;
  const collapsedClusters = new Set();
  let highlightedNode = null;
  
  let components, relations;
  let selectedProperties = [];
  let styleConfig = {}; // New variable to store parsed style configuration
  let currentScale = 1;
  let currentTranslate = [0, 0];
  let placeholders=[];
//////////////////////////////////////
// Init
//////////////////////////////////////

  async function initializeGraphviz() {
    try {
	  await Graphviz.unload();
      graphviz = await Graphviz.load();
    } catch (error) {
      console.error("Error loading Graphviz:", error);
      document.getElementById("graph-container").innerHTML = "Error loading Graphviz. Please check the console for details.";
    }
  }

   // Initialize and set up event listeners
  async function initialize() {
    
    initialDotSrc = document.getElementById('dot-src').value;
	const { processedInput} = escapeHtmlLabels(initialDotSrc);
	//console.log("escaped");
	//console.log(processedInput);
    parseAndRenderGraph(processedInput);
  }
//////////////////////////////////////
// HTML escaping
/////////////////////////////////////  
function escapeHtmlLabels(input) {
  const htmlLabelRegex = /label\s*=\s*(<[\s\S]?<[\s\S]*?>[\s\S]?>)/g;
  
  placeholders = [];
  
  const escapedInput = input.replace(htmlLabelRegex, (match, p1) => {
    const placeholder = `__HTML_LABEL_PLACEHOLDER_${placeholders.length}__`;
    placeholders.push(p1);
    return match.replace(/<[\s\S]?<[\s\S]*?>[\s\S]?>/, placeholder);
  });
  
  return {
    processedInput: escapedInput  };
}

function restoreHtmlLabels(processedInput) {
    
  if (!Array.isArray(placeholders) || placeholders.length === 0) {
    return processedInput;
  }
  
  let restoredInput = processedInput;
  placeholders.forEach((label, index) => {
    const placeholder = `__HTML_LABEL_PLACEHOLDER_${index}__`;
    restoredInput = restoredInput.replace(new RegExp(placeholder, 'g'), label);
  });
  
  return restoredInput;
}

//////////////////////////////////////
// File handling
/////////////////////////////////////  

  // Function to parse CSV content
function parseCSV(csvContent) {
  const lines = csvContent.split('\n');
  const headers = lines[0].split(',').map(header => header.trim());
  const data = [];

  for (let i = 1; i < lines.length; i++) {
    const values = lines[i].split(',').map(value => value.trim());
    if (values.length === headers.length) {
      const row = {};
      headers.forEach((header, index) => {
        row[header] = values[index];
      });
      data.push(row);
    }
  }

  return data;
}

// Function to read CSV files
function readCSVFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (event) => {
      const csvContent = event.target.result;
      const parsedData = parseCSV(csvContent);
      resolve(parsedData);
    };
    reader.onerror = (error) => reject(error);
    reader.readAsText(file);
  });
}

function generateGraph(components, relations, clusterProperties, subclusterProperties, classProperties) {
  const graph = new graphlibDot.graphlib.Graph({ directed: true, compound: true });

  // Apply graph-level styles
  if (styleConfig.graph) {
    const graphStyles = Object.entries(styleConfig.graph).reduce((acc, [key, value]) => {
      acc[key] = value;
      return acc;
    }, {});
    
    graph.setGraph(graphStyles);
  }

  // Create clusters based on selected properties
  const clusters = {};
  components.forEach(component => {
    const clusterKey = clusterProperties.map(prop => component[prop]).join('-');
    const subclusterKey = subclusterProperties.map(prop => component[prop]).join('-');
    
    if (!clusters[clusterKey]) {
      clusters[clusterKey] = {};
    }
    if (!clusters[clusterKey][subclusterKey]) {
      clusters[clusterKey][subclusterKey] = [];
    }
    clusters[clusterKey][subclusterKey].push(component);
  });

  // Add clusters, subclusters, and nodes to the graph
  Object.entries(clusters).forEach(([clusterKey, subclusters], clusterIndex) => {
    const clusterId = `cluster_${clusterIndex}`;
    const clusterAttrs = { label: clusterKey, ...styleConfig.cluster };
    graph.setNode(clusterId, clusterAttrs);

    Object.entries(subclusters).forEach(([subclusterKey, components], subclusterIndex) => {
      const subclusterId = `${clusterId}_subcluster_${subclusterIndex}`;
      const subclusterAttrs = { label: subclusterKey, ...styleConfig.subCluster };
      graph.setNode(subclusterId, subclusterAttrs);
      graph.setParent(subclusterId, clusterId);

      components.forEach(component => {
        // Generate class attribute based on classProperties
        const classValues = classProperties.flatMap(prop => {
          const value = component[prop].trim().replace(/\s+/g, '-');
          return [`${value}`];
        });
        const classAttribute = classValues.join(' ');

        const nodeAttrs = { 
          label: component.Node, 
          ...styleConfig.node,
          class: classAttribute  // Add the class attribute
        };

        graph.setNode(component.Node, nodeAttrs);
        graph.setParent(component.Node, subclusterId);
      });
    });
  });

  // Add edges to the graph
  relations.forEach(relation => {
    const edgeAttrs = { ...styleConfig.edge };
    graph.setEdge(relation.from, relation.to, edgeAttrs);
  });

  return graph;
}

function handleFileLoad() {
  const componentFile = document.getElementById('component-file').files[0];
  const relationFile = document.getElementById('relation-file').files[0];
  const styleFile = document.getElementById('style-file').files[0];
  if (!componentFile || !relationFile) {
    alert('Please select both component and relation CSV files.');
    return;
  }
  Promise.all([
    readCSVFile(componentFile),
    readCSVFile(relationFile),
    readTextFile(styleFile)
  ]).then(([components, relations, styleContent]) => {
    //console.log("Loaded components:", components);
    //console.log("Loaded relations:", relations);
    // Parse the style file
    styleConfig = parseStyleFile(styleContent);
    //console.log("Parsed style configuration:", styleConfig);
		
    // Get unique properties from components
    const uniqueProperties = [...new Set(components.flatMap(Object.keys))];
    //console.log("Unique properties: ", uniqueProperties);
    
    // Create property selectors
    const clusterSelector = createPropertySelector(uniqueProperties, "Select Properties for Clusters");
    const subclusterSelector = createPropertySelector(uniqueProperties, "Select Properties for Subclusters");
    const classSelector = createPropertySelector(uniqueProperties, "Select Properties for Classes");
    
    const container = document.getElementById('property-selector-container');
    container.innerHTML = ''; // Clear previous content
    
    // Create a flex container for the selectors
    const flexContainer = document.createElement('div');
    flexContainer.style.display = 'flex';
    flexContainer.style.justifyContent = 'space-between';
    flexContainer.style.marginBottom = '10px';
    
    // Add selectors to the flex container
    flexContainer.appendChild(clusterSelector.container);
    flexContainer.appendChild(subclusterSelector.container);
    flexContainer.appendChild(classSelector.container);
    
    // Add the flex container to the main container
    container.appendChild(flexContainer);
    
    // Create a single Apply button
    const applyButton = document.createElement('button');
    applyButton.textContent = 'Apply';
    applyButton.addEventListener('click', () => {
      const selectedClusterProperties = clusterSelector.getSelectedProperties();
      const selectedSubclusterProperties = subclusterSelector.getSelectedProperties();
      const selectedClassProperties = classSelector.getSelectedProperties();
      updateGraph(components, relations, selectedClusterProperties, selectedSubclusterProperties, selectedClassProperties);
    });
    container.appendChild(applyButton);
    
    // Store components and relations in global variables or state
    window.components = components;
    window.relations = relations;
  }).catch(error => {
    console.error('Error loading CSV files:', error);
    alert('Error loading CSV files. Please check the console for details.');
  });
}
function createPropertySelector(properties, title) {
  const container = document.createElement('div');
  container.className = 'property-selector';
  container.style.width = '30%'; // Set width to roughly 1/3 of the container
  container.style.display = 'inline-block'; // Allow horizontal alignment
  container.style.verticalAlign = 'top'; // Align tops of the columns

  const heading = document.createElement('h3');
  heading.textContent = title;
  container.appendChild(heading);

  const checkboxContainer = document.createElement('div');
  checkboxContainer.style.maxHeight = '200px'; // Set a max height
  checkboxContainer.style.overflowY = 'auto'; // Make it scrollable if content exceeds max height
  container.appendChild(checkboxContainer);

  const selectedProperties = new Set();

  properties.forEach(property => {
    const label = document.createElement('label');
    label.style.display = 'block'; // Stack checkboxes vertically
    label.style.marginBottom = '5px'; // Add some space between checkboxes

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = property;
    
    checkbox.addEventListener('change', (e) => {
      if (e.target.checked) {
        selectedProperties.add(property);
      } else {
        selectedProperties.delete(property);
      }
    });

    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(' ' + property));
    checkboxContainer.appendChild(label);
  });

  return {
    container,
    getSelectedProperties: () => Array.from(selectedProperties)
  };
}

function updateGraph(components, relations, clusterProperties, subclusterProperties, classProperties) {
  const graph = generateGraph(components, relations, clusterProperties, subclusterProperties, classProperties);
  document.getElementById('dot-src').value = graphlibDot.write(graph);
  initialize();
}

function parseStyleFile(content) {
      const lines = content.split('\n');
      let currentSection = '';
      const config = {};

      lines.forEach(line => {
        line = line.trim();
        if (line.startsWith('[') && line.endsWith(']')) {
          currentSection = line.slice(1, -1);
          config[currentSection] = {};
        } else if (line && currentSection) {
          const [key, value] = line.split('=').map(s => s.trim());
          config[currentSection][key] = value.replace(/"/g, '');
        }
      });

      return config;
    } 
 // New function to read text files (for the style file)
    function readTextFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => resolve(event.target.result);
        reader.onerror = (error) => reject(error);
        reader.readAsText(file);
      });
    }
//////////////////////////////////////
// Graph Parsing and rendering
/////////////////////////////////////  
 function parseAndRenderGraph(dotSrc) {
    try {
      graph = graphlibDot.read(dotSrc);
      originalGraph = graphlibDot.read(dotSrc); // Keep a copy of the original graph
      //console.log("Graph structure:", graph);

      renderGraph(dotSrc);
	  //Populate the faceted navigation after the graph is parsed
      populateFacetedNavigation();
    } catch (error) {
      console.error("Error parsing DOT source:", error);
      document.getElementById("graph-container").innerHTML = "Error parsing DOT source. Please check the console for details.";
    }
  }

  async function renderGraph(dotSrc) {
    try {
	  //console.log(dotSrc);
	  const finalDot = restoreHtmlLabels(dotSrc);
	  //console.log(finalDot);
	  await initializeGraphviz();
      const svg = await graphviz.layout(finalDot, "svg", "dot");
      document.getElementById("graph-container").innerHTML = svg;

      
      const width = svg.match(/width="([0-9.]+pt)"/)[1];
      const height = svg.match(/height="([0-9.]+pt)"/)[1];
	  

      const svgContainer = document.getElementById("svg-container");
	  const graphContainer = document.getElementById("graph-container");
      svgContainer.setAttribute("width", width);
      svgContainer.setAttribute("height", height);
	  currentScale = 1;
      currentTranslate = [0, 0];
	  graphContainer.style.transform = `translate(${currentTranslate[0]}px, ${currentTranslate[1]}px) scale(${currentScale})`;
	  svgContainer.addEventListener("wheel", handleZoom);

      addClusterEventListeners();

      addNodeEventListeners();
      animateGraphChanges();
    } catch (error) {
      console.error("Error rendering graph:", error);
      document.getElementById("graph-container").innerHTML = "Error rendering graph. Please check the console for details.";
    }
  }
  
//////////////////////////////////////
// Graph Animation
///////////////////////////////////// 
 
  function animateGraphChanges() {
    const nodes = document.querySelectorAll(".node");
    const edges = document.querySelectorAll(".edge");

    // Animate nodes
    nodes.forEach(node => {
      node.style.opacity = 0;
      node.style.transition = "opacity 2s";
      setTimeout(() => {
        node.style.opacity = 1;
      }, 10);
    
      // Animate label
      const label = node.querySelector("text");
      if (label) {
        label.style.opacity = "0";
        setTimeout(() => {
          label.style.opacity = "1";
        }, 300);
      }
    });

    // Animate edges
    edges.forEach(edge => {
      animateEdge(edge);
    });
  }

function animateEdge(edge){
    let pathList = edge.querySelectorAll('path');
    for (let i = 0; i < pathList.length; i++) {
        let path = pathList[i];
        let length = path.getTotalLength();
        // Clear any previous transition
        path.style.transition = path.style.WebkitTransition = 'none';
        // Set up the starting positions
        path.style.strokeDasharray = length + ' ' + length;
        path.style.strokeDashoffset = length;
        // Trigger a layout so styles are calculated & the browser
        // picks up the starting position before animating
        path.getBoundingClientRect();
        // Define our transition
        path.style.transition = path.style.WebkitTransition = 'stroke-dashoffset 2s ease-in-out';
        path.style.strokeDashoffset = '0';
    }
    let polygonList = edge.querySelectorAll('polygon');
    for (let i = 0; i < polygonList.length; i++) {
        let polygon = polygonList[i];
        polygon.style.transition = polygon.style.WebkitTransition = 'none';
        polygon.style.opacity='0';
        polygon.style.transition = polygon.style.WebkitTransition = 'fill-opacity 1s ease-in-out 2s';
        setTimeout(function(){polygon.style.opacity='1';},2000)
    }
}
function handleZoom(event) {
  event.preventDefault(); // Prevent the default page scroll
 // Get the SVG container element   
  const svgContainer = document.getElementById("svg-container");

  // Get the graph container element inside the SVG container  
  const graphContainer = document.getElementById("graph-container");
  // Get the mouse position relative to the SVG container
  const rect = svgContainer.getBoundingClientRect();
  const mouseX = event.clientX - rect.left;
  const mouseY = event.clientY - rect.top;

  // Determine the scaling factor based on the scroll direction
  let scaleFactor = 1.1;
  if (event.deltaY < 0) {
    scaleFactor = 1 / 1.1; // Zoom in
  } else {
    scaleFactor = 1.1; // Zoom out
  }

  // Update the current scale, considering the mouse position
  currentScale *= scaleFactor;
  graphContainer.style.transformOrigin = `${mouseX}px ${mouseY}px`;
  graphContainer.style.transform = `scale(${currentScale})`;
}


 
//////////////////////////////////////
// Event Listeners
///////////////////////////////////// 
  function addClusterEventListeners() {
    const clusters = document.querySelectorAll("g[class^='cluster']");
    clusters.forEach(cluster => {
      cluster.addEventListener("click", () => {
        const titleElement = cluster.querySelector("title");
        if (titleElement) {
          const clusterId = titleElement.textContent.trim();
          toggleCluster(clusterId);
        }
      });
    });
  }

 function addNodeEventListeners() {
  const nodes = document.querySelectorAll(".node");
  const contextMenu = document.getElementById('context-menu');
  let selectedNodeId = null;

  nodes.forEach(node => {
    node.addEventListener("click", (event) => {
      event.stopPropagation();
      const titleElement = node.querySelector("title");
      if (titleElement) {
        const nodeId = titleElement.textContent.trim();
        toggleHighlightConnectedEdges(nodeId);
      }
    });

    node.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      const titleElement = node.querySelector("title");
      if (titleElement) {
        selectedNodeId = titleElement.textContent.trim();
        contextMenu.style.display = 'block';
        contextMenu.style.left = `${event.clientX}px`;
        contextMenu.style.top = `${event.clientY}px`;
      }
    });
  });

  document.addEventListener("click", () => {
    contextMenu.style.display = 'none';
  });

  document.getElementById('highlight-node').addEventListener('click', () => {
    if (selectedNodeId) {
      toggleHighlightConnectedEdges(selectedNodeId);
      contextMenu.style.display = 'none';
    }
  });

  document.getElementById('filter-graph').addEventListener('click', () => {
    if (selectedNodeId) {
      filterGraphByNode(selectedNodeId);
      contextMenu.style.display = 'none';
    }
  });

  // Reset selectedNodeId when context menu is hidden
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
        if (contextMenu.style.display === 'none') {
          selectedNodeId = null;
        }
      }
    });
  });
    document.getElementById('component-file').addEventListener('change', function(e) {
      document.getElementById('component-file-name').textContent = e.target.files[0] ? e.target.files[0].name : 'No file chosen';
    });
    document.getElementById('relation-file').addEventListener('change', function(e) {
      document.getElementById('relation-file-name').textContent = e.target.files[0] ? e.target.files[0].name : 'No file chosen';
    });
    document.getElementById('style-file').addEventListener('change', function(e) {
      document.getElementById('style-file-name').textContent = e.target.files[0] ? e.target.files[0].name : 'No file chosen';
    });
  observer.observe(contextMenu, { attributes: true });
}

//////////////////////////////////////
// Highlighting
/////////////////////////////////////  
 function toggleHighlightConnectedEdges(nodeId) {
    if (highlightedNode === nodeId) {
      // If clicking the same node, remove highlighting
      removeHighlighting();
      highlightedNode = null;
    } else {
      // Remove previous highlighting
      removeHighlighting();
      // Highlight new node and its edges
      highlightConnectedEdges(nodeId);
      highlightedNode = nodeId;
    }
    renderGraph(graphlibDot.write(graph));
  }

  function highlightConnectedEdges(nodeId) {
    const connectedEdges = graph.nodeEdges(nodeId);
    connectedEdges.forEach(edge => {
      // Use edge.v and edge.w to get the source and target nodes
      const edgeObj = graph.edge(edge.v, edge.w);
      if (edgeObj) {
        // Store the original style
        edgeObj.originalStyle = edgeObj.style || '';
        edgeObj.originalColor = edgeObj.color || '';
        edgeObj.originalPenwidth = edgeObj.penwidth || '1';
        
        // Set new style for highlighting
        edgeObj.style = 'bold';
        edgeObj.color = 'red';
        edgeObj.penwidth = '2';
      }
    });
  }

   function removeHighlighting() {
    if (highlightedNode) {
      const connectedEdges = graph.nodeEdges(highlightedNode);
	  if (connectedEdges) {
      connectedEdges.forEach(edge => {
        const edgeObj = graph.edge(edge.v, edge.w);
        if (edgeObj) {
          // Restore original style
          edgeObj.style = edgeObj.originalStyle || '';
          edgeObj.color = edgeObj.originalColor || '';
          edgeObj.penwidth = edgeObj.originalPenwidth || '1';
          
          // Clean up temporary properties
          delete edgeObj.originalStyle;
          delete edgeObj.originalColor;
          delete edgeObj.originalPenwidth;
        }
      });
	 } 
    }
  }


//////////////////////////////////////
// filtergraph by node
//////////////////////////////////////   
function filterGraphByNode(nodeId) {
  // Get all nodes in the graph
  const allNodes = graph.nodes();
  
  // Get adjacent nodes
  const adjacentNodes = graph.neighbors(nodeId);
  
  // Nodes to keep (selected node and its neighbors)
  const nodesToKeep = new Set([nodeId, ...adjacentNodes]);
  
  // Function to get all parent clusters of a node
  function getParentClusters(node) {
    const parents = [];
    let parent = graph.parent(node);
    while (parent) {
      parents.push(parent);
      parent = graph.parent(parent);
    }
    return parents;
  }
  
  // Add parent clusters of all nodes to keep
  nodesToKeep.forEach(node => {
    const parents = getParentClusters(node);
    parents.forEach(parent => nodesToKeep.add(parent));
  });
  
  // Remove nodes that are not in nodesToKeep
  allNodes.forEach(node => {
    if (!nodesToKeep.has(node)) {
      graph.removeNode(node);
    }
  });
  
  // Remove edges that are not connected to the selected node or its neighbors
  graph.edges().forEach(edge => {
    if (!nodesToKeep.has(edge.v) || !nodesToKeep.has(edge.w)) {
      graph.removeEdge(edge);
    }
  });
  
  // Render the updated graph
  renderGraph(graphlibDot.write(graph));
}


//////////////////////////////////////
// Cluster Handling
//////////////////////////////////////   
   function toggleCluster(clusterId) {
    //console.log(`Toggling cluster: ${clusterId}`);
    if (!graph.hasNode(clusterId)) {
      console.error(`Cluster ${clusterId} not found in the graph`);
      return;
    }

    if (collapsedClusters.has(clusterId)) {
      expandCluster(clusterId);
    } else {
      collapseCluster(clusterId);
    }
    //console.log(graphlibDot.write(graph));
    renderGraph(graphlibDot.write(graph));
  }

function expandCluster(clusterId,isRestoring = false) {
  //console.log(`Expanding cluster: ${clusterId}`);
  
  const collapsedNodeId = `${clusterId}_collapsed`;
  const clusterNodes = originalGraph.children(clusterId);

  // Restore nodes
  clusterNodes.forEach(nodeId => {
    const nodeAttrs = originalGraph.node(nodeId);
    graph.setNode(nodeId, nodeAttrs);
    graph.setParent(nodeId, clusterId);

    // Recursively expand subclusters
    if (originalGraph.children(nodeId).length > 0) {
      expandCluster(nodeId);
    }
  });
  
  // Remove all edges connected to the collapsed node
  graph.edges().forEach(edge => {
    if (edge.v === collapsedNodeId || edge.w === collapsedNodeId) {
      //console.log(`Removing edge connected to collapsed node ${collapsedNodeId}`);
      graph.removeEdge(edge.v, edge.w);
    }
  });
  
  // Remove the collapsed node
  graph.removeNode(collapsedNodeId);
  
  // Update the cluster node
  graph.node(clusterId).collapsed = false;

  // Remove the collapsed state
  collapsedClusters.delete(clusterId);

  // Restore original edges, ensuring we do not create invalid edges
  originalGraph.edges().forEach(edge => {
    if (clusterNodes.includes(edge.v) || clusterNodes.includes(edge.w)) {
      const sourceNode = getHighestCollapsedParent(edge.v);
      const targetNode = getHighestCollapsedParent(edge.w);

      // Only add the edge if both nodes are valid
      if (graph.hasNode(sourceNode) && graph.hasNode(targetNode)) {
        const edgeAttrs = originalGraph.edge(edge);
        //console.log(`Restoring edge from ${sourceNode} to ${targetNode}`);
        graph.setEdge(sourceNode, targetNode, edgeAttrs);
      }
    }
  });

  //console.log(`Cluster ${clusterId} expanded`);
}

function collapseCluster(clusterId, removeCompletely = false) {
  
  if (!collapsedClusters.has(clusterId)){
  //console.log(`Collapsing cluster: ${clusterId}`);
  
  // Collect all nodes from the cluster and its subclusters
  const allClusterNodes = Array.from(collectAllNodes(clusterId));

  // Store the collapsed state
  collapsedClusters.add(clusterId);

  // Also add all subclusters to collapsedClusters
  const subclusters = getSubclusters(clusterId);
  subclusters.forEach(subcluster => collapsedClusters.add(subcluster));

  if (!removeCompletely) {
    // Create a new collapsed node only for the highest level cluster
    const collapsedNodeId = `${clusterId}_collapsed`;
    graph.setNode(collapsedNodeId, {
      label: `${graph.node(clusterId).label}\n(collapsed)`,
      shape: 'rectangle',
      style: 'filled,dashed'
    });
    graph.setParent(collapsedNodeId, clusterId);

    // Redirect edges
    redirectEdgesToCollapsedNode(clusterId, collapsedNodeId, allClusterNodes);
  }

  // Remove original nodes
  allClusterNodes.forEach(nodeId => graph.removeNode(nodeId));

  // Update the cluster node
  graph.node(clusterId).collapsed = true;

  //console.log(`Cluster ${clusterId} collapsed`);
 }
}

//////////////////////////////////////
// Faceted Navigation
//////////////////////////////////////   
    function populateFacetedNavigation() {
      const clustersList = document.getElementById('clusters-list');
      const numericalClassesList = document.getElementById('numerical-classes-list');
      const alphanumericClassesList = document.getElementById('alphanumeric-classes-list');

      // Clear existing lists
      clustersList.innerHTML = '';
      numericalClassesList.innerHTML = '';
      alphanumericClassesList.innerHTML = '';

      // Create a tree structure for clusters
      const clusterTree = createClusterTree();

      // Render the cluster tree
      renderClusterTree(clusterTree, clustersList);

      // Get all unique classes from nodes, edges, and clusters
      const classes = new Set();
      
      // Nodes and clusters
	  graph.nodes().forEach(nodeId => {
		const classAttr = graph.node(nodeId).class;
		if (classAttr) {
		  classAttr.split(' ').forEach(cls => classes.add(cls));
		}
	  });

	  // Edges
	  graph.edges().forEach(edge => {
		const classAttr = graph.edge(edge.v, edge.w).class;
		if (classAttr) {
		  classAttr.split(' ').forEach(cls => classes.add(cls));
		}
	  });

      // Separate numerical and alphanumeric classes
      const numericalClasses = [];
      const alphanumericClasses = [];

      classes.forEach(cls => {
        if (/^\d+$/.test(cls)) {
          numericalClasses.push(parseInt(cls, 10));
        } else {
          alphanumericClasses.push(cls);
        }
      });

      // Sort numerical classes
      numericalClasses.sort((a, b) => a - b);

      // Sort alphanumeric classes alphabetically
      alphanumericClasses.sort();

      // Render numerical classes with a slider
  if (numericalClasses.length > 0) {
  const min = numericalClasses[0];
  const max = numericalClasses[numericalClasses.length - 1];
  
  // Create the slider
  numericalClassesList.innerHTML = `
    <div class="slider-container">
      <input type="range" min="${min}" max="${max}" value="${max}" class="slider" id="numerical-class-slider">
      <p>Selected value: <span id="slider-value">${max}</span></p>
    </div>
  `;

  // Create checkboxes for each numerical class
  numericalClasses.forEach(cls => {
    numericalClassesList.innerHTML += `
      <label>
        <input type="checkbox" checked data-class="${cls}" class="primary-checkbox"> ${cls}
      </label>
	   <label>
            <input type="checkbox" unchecked data-class="${cls}" class="secondary-checkbox">
       </label><br>
      <br>
    `;
  });

  const slider = document.getElementById('numerical-class-slider');
  
  slider.oninput = function() {
    applyNumericalClassFilter(this.value);
  };
  }

      // Render alphanumeric classes
      alphanumericClasses.forEach(cls => {
        alphanumericClassesList.innerHTML += `
          <label>
            <input type="checkbox" checked data-class="${cls}" class="primary-checkbox"> ${cls}
          </label>
          <label>
            <input type="checkbox" unchecked data-class="${cls}" class="secondary-checkbox">
          </label><br>
        `;
      });

   // Add event listeners for checkboxes
  document.querySelectorAll('#clusters-list input').forEach(checkbox => {
    checkbox.addEventListener('change', () => toggleSubclusters(checkbox.dataset.cluster, checkbox.checked));
  });
  // Add event listeners for secondary checkboxes
  document.querySelectorAll('#alphanumeric-classes-list .secondary-checkbox').forEach(checkbox => {
  checkbox.addEventListener('change', () => highlightClass(checkbox.dataset.class, checkbox.checked));
  });
    // Add event listeners for secondary checkboxes
  document.querySelectorAll('#numerical-classes-list .secondary-checkbox').forEach(checkbox => {
  checkbox.addEventListener('change', () => highlightClass(checkbox.dataset.class, checkbox.checked));
  });
	// Add event listener for the "Apply Filter" button
	const applyFilterButton = document.getElementById('apply-filter-button');
	if (applyFilterButton) {
	  applyFilterButton.addEventListener('click', applyFilters);
	} else {
	  console.error('Apply Filter button not found in the DOM');
	}
	// Add event listener for the numerical class slider
      const slider = document.getElementById('numerical-class-slider');
      if (slider) {
        slider.addEventListener('change', () => applyNumericalClassFilter(slider.value));
      }
}

function applyNumericalClassFilter(maxValue) {
  // Get all primary checkboxes for numerical classes
  const numericalCheckboxes = document.querySelectorAll('#numerical-classes-list .primary-checkbox');
  
  numericalCheckboxes.forEach(checkbox => {
    const classValue = parseInt(checkbox.dataset.class, 10);
    if (!isNaN(classValue)) {
      // If the class value is less than or equal to maxValue, check the box; otherwise, uncheck it
      checkbox.checked = classValue <= maxValue;
    }
  });
  // Update the displayed value
  const sliderValue = document.getElementById('slider-value');
  if (sliderValue) {
    sliderValue.textContent = maxValue;
  }
}

function createClusterTree() {
  const tree = {};

  // Helper function to get or create a path in the tree
  function getOrCreatePath(path) {
    return path.reduce((subtree, key) => {
      if (!subtree[key]) subtree[key] = {};
      return subtree[key];
    }, tree);
  }

  // Identify all clusters (nodes with children)
  const clusters = graph.nodes().filter(nodeId => graph.children(nodeId).length > 0);

  // For each cluster, create its path in the tree
  clusters.forEach(clusterId => {
    const path = [];
    let current = clusterId;
    while (current) {
      path.unshift(current);
      current = graph.parent(current);
    }
    getOrCreatePath(path);
  });

  return tree;
}

function renderClusterTree(tree, container, level = 0) {
  Object.keys(tree).forEach(clusterId => {
    const label = graph.node(clusterId).label || clusterId;
    const div = document.createElement('div');
    div.style.marginLeft = `${level * 20}px`;
    div.innerHTML = `<label><input type="checkbox" checked data-cluster="${clusterId}"> ${label}</label>`;
    container.appendChild(div);

    // Recursively render children
    renderClusterTree(tree[clusterId], container, level + 1);
  });
}
function toggleClassVisibility(className, isVisible) {
  if (!graph) return;

  if (!isVisible) {
    //console.log("starting filter");
    // Identify clusters to remove
    const clustersToRemove = graph.nodes().filter(clusterId => {
      const cluster = graph.node(clusterId);
      const clusterClasses = (cluster.class || '').split(' ');
      return clusterClasses.includes(className) && graph.children(clusterId).length > 0;
    });

    // Remove identified clusters and their children
    clustersToRemove.forEach(clusterId => {
	  if(graph.hasNode(clusterId)){
      const childNodes = collectAllNodes(clusterId);
      childNodes.forEach(childId => {
        const connectedEdges = graph.nodeEdges(childId);
        connectedEdges.forEach(edge => {
          graph.removeEdge(edge.v, edge.w);
        });
        graph.removeNode(childId);
      });
      graph.removeNode(clusterId);
     }
	});

    // Identify nodes to remove
    const nodesToRemove = graph.nodes().filter(nodeId => {
      const node = graph.node(nodeId);
      const nodeClasses = (node.class || '').split(' ');
      return nodeClasses.includes(className);
    });
    // keep clusters to verify later if they have been emptied
	let allClusters = graph.nodes().filter(clusterId => graph.children(clusterId).length > 0);
	
    // Remove identified nodes and their edges
    nodesToRemove.forEach(nodeId => {
      const connectedEdges = graph.nodeEdges(nodeId);
      connectedEdges.forEach(edge => {
        graph.removeEdge(edge.v, edge.w);
      });
      graph.removeNode(nodeId);
    });

    // Remove edges that have the class
    const edgesToRemove = graph.edges().filter(edge => {
      const edgeObj = graph.edge(edge.v, edge.w);
	  if (!edgeObj) {
      return false;
      }
      if (!edgeObj.hasOwnProperty('class')) {
      return false;
      }
      const edgeClasses = (edgeObj.class || '').split(' ');
      return edgeClasses.includes(className);
    });

    edgesToRemove.forEach(edge => {
      graph.removeEdge(edge.v, edge.w);
    });

    // After removing nodes, check for empty clusters and remove them
  

  let repeat=true;
  while (repeat) {
  repeat=false;
  allClusters.forEach(clusterId => {
    if (graph.children(clusterId) && graph.children(clusterId).length === 0) {
      graph.removeNode(clusterId);
	  repeat=true;
      }
    });
  }


  } else {
    // Re-render the graph with the class added back
    graph = graphlibDot.read(initialDotSrc);
  }

 // renderGraph(graphlibDot.write(graph));
}



function applyFilters() {
  //console.log('Applying filters');
  // Create a new graph based on the original
  //console.log(graphlibDot.read(initialDotSrc));
  const {processedInput} = escapeHtmlLabels(initialDotSrc);
  Object.assign(graph, graphlibDot.read(processedInput));
  //console.log('before filtering graph', graph);
  collapsedClusters.clear();
  
  // Apply cluster filters
  document.querySelectorAll('#clusters-list input').forEach(checkbox => {
    if (!checkbox.checked) {
      //console.log(`Unchecked cluster: ${checkbox.dataset.cluster}`);
      collapseCluster(checkbox.dataset.cluster, false);  // true for complete removal
    }
  });
  //console.log('after cluster filter:', graph);
  // Apply class filters
  const visibleClasses = new Set();
  document.querySelectorAll('#alphanumeric-classes-list .primary-checkbox').forEach(checkbox => {
    if (checkbox.checked) {
      visibleClasses.add(checkbox.dataset.class);
    }
	else
	{
	toggleClassVisibility(checkbox.dataset.class,false);
	}
  });
  
  document.querySelectorAll('#numerical-classes-list .primary-checkbox').forEach(checkbox => {
    if (checkbox.checked) {
      visibleClasses.add(checkbox.dataset.class);
    }
	else
	{
	toggleClassVisibility(checkbox.dataset.class,false);
	}
  });
 
  //console.log('Visible classes:', visibleClasses);
  
  //console.log('Final filtered graph:', graph);
  //console.log (graphlibDot.write(graph));

  // Render the updated graph
  renderGraph(graphlibDot.write(graph));
}

function toggleSubclusters(clusterId, isVisible) {
  // Get the list of subclusters for the provided clusterId
  const subClusters = getSubclusters(clusterId);

  subClusters.forEach(subClusterId => {
    // Get the checkbox for the current subcluster
    const subClusterCheckbox = document.querySelector(`input[data-cluster="${subClusterId}"]`);
    
    if (subClusterCheckbox) {
      // Set the checkbox state
      subClusterCheckbox.checked = isVisible;
      
      // Recursively toggle visibility for child subclusters
      toggleSubclusters(subClusterId, isVisible);
    }
  });
}

function highlightClass(className, isChecked) {
  if (!graph) return;
    // Identify nodes to highlight
    const nodesToHighlight = graph.nodes().filter(nodeId => {
      const node = graph.node(nodeId);
      const nodeClasses = (node.class || '').split(' ');
      return nodeClasses.includes(className);
    });
	
	   // identify edges
    const edgesToHighlight = graph.edges().filter(edge => {
      const edgeObj = graph.edge(edge.v, edge.w);
	  if (!edgeObj) {
      return false;
      }
      if (!edgeObj.hasOwnProperty('class')) {
      return false;
      }
      const edgeClasses = (edgeObj.class || '').split(' ');
      return edgeClasses.includes(className);
    });
	
    nodesToHighlight.forEach(node => {
      highlightNode(node, isChecked);
    });
 

    edgesToHighlight.forEach(edge => {
      highlightEdge(edge, isChecked);
    });
renderGraph(graphlibDot.write(graph));
}

//////////////////////////////////////
// Utilities
//////////////////////////////////////

function highlightNode(elementId,highLight) {
    const element= graph.node(elementId);
    if (element) {
	if (highLight) {
        // Store the original style
       element.originalStyle = element.style || '';
        element.originalColor = element.color || '';
        element.originalPenwidth = element.penwidth || '1';
        
        // Set new style for highlighting
        element.style = 'bold';
        element.color = 'red';
        element.penwidth = '4';
      }
	  else{
		//restore original style
	    element.style = element.originalStyle || '';
        element.color = element.originalColor || '';
        element.penwidth = element.originalPenwidth || '1';
         
        // Clean up temporary properties
        delete element.originalStyle;
        delete element.originalColor;
        delete element.originalPenwidth;
	  }
	};
}
  
  
  function highlightEdge(elementId,highLight) {
    const element= graph.edge(elementId);
    if (element) {
	if (highLight) {
        // Store the original style
       element.originalStyle = element.style || '';
        element.originalColor = element.color || '';
        element.originalPenwidth = element.penwidth || '1';
        
        // Set new style for highlighting
        element.style = 'bold';
        element.color = 'red';
        element.penwidth = '4';
      }
	  else{
		//restore original style
	    element.style = element.originalStyle || '';
        element.color = element.originalColor || '';
        element.penwidth = element.originalPenwidth || '1';
         
        // Clean up temporary properties
        delete element.originalStyle;
        delete element.originalColor;
        delete element.originalPenwidth;
	  }
	};
}

function getHighestCollapsedParent(nodeId) {
  let currentNode = nodeId;
  //console.log(`Starting cluster determination for node ${nodeId}`);
  // Iterate up through parent clusters with a fixed maximum depth to prevent infinite loops
  const maxDepth = 10; // A reasonable limit to prevent excessive iterations
  for (let depth = 0; depth < maxDepth; depth++) {
    const parentCluster = originalGraph.parent(currentNode);
    
    if (!parentCluster) {
      //console.log(`Determined cluster ${currentNode}`);
      return currentNode;
    }
    
    if (!collapsedClusters.has(parentCluster)) {
      if (graph.hasNode(currentNode)) {
        //console.log(`Determined cluster ${currentNode}`);
        return currentNode;
      } else {
        // If the current node doesn't exist in the graph, return its parent
        //console.log(`Node ${currentNode} doesn't exist, returning parent ${parentCluster}`);
        return parentCluster;
      }
    }
    
    // Move to the collapsed node of the parent cluster
	if (collapsedClusters.has(originalGraph.parent(parentCluster))) {
    currentNode = `${parentCluster}`;
	}
	else{
	currentNode = `${parentCluster}_collapsed`;
	}
  }

  // If maximum depth is reached, log an error
  console.error(`Maximum depth reached while finding the highest collapsed parent for node ${nodeId}`);
  //console.log(`Determined cluster ${currentNode}`);
  return currentNode;
}

function getSubclusters(clusterId) {
  const subclusters = [];
  function collectSubclusters(id) {
    const children = originalGraph.children(id);
    children.forEach(childId => {
      if (originalGraph.children(childId).length > 0) {
        subclusters.push(childId);
        collectSubclusters(childId);
      }
    });
  }
  collectSubclusters(clusterId);
  return subclusters;
}

function redirectEdgesToCollapsedNode(clusterId, collapsedNodeId, allClusterNodes) {
  graph.edges().forEach(edge => {
    //console.log(`Processing edge from ${edge.v} to ${edge.w}`);
    if (allClusterNodes.includes(edge.v) && !allClusterNodes.includes(edge.w)) {
      // Outgoing edge from cluster or subcluster
      const targetNode = edge.w;
      const targetCluster = graph.parent(targetNode);
      if (targetCluster && collapsedClusters.has(targetCluster)) {
        // Target node is in a collapsed cluster, redirect to its collapsed node
        //console.log(`Redirecting edge from ${edge.v} to ${targetCluster}_collapsed`);
        graph.removeEdge(edge.v, edge.w);
        graph.setEdge(collapsedNodeId, `${targetCluster}_collapsed`, graph.edge(edge));
      } else {
        // Target node is not in a collapsed cluster
        //console.log(`Redirecting edge from ${edge.v} to ${targetNode}`);
        graph.removeEdge(edge.v, edge.w);
        graph.setEdge(collapsedNodeId, targetNode, graph.edge(edge));
      }
    } else if (!allClusterNodes.includes(edge.v) && allClusterNodes.includes(edge.w)) {
      // Incoming edge to cluster or subcluster
      const sourceNode = edge.v;
      const sourceCluster = graph.parent(sourceNode);
      if (sourceCluster && collapsedClusters.has(sourceCluster)) {
        // Source node is in a collapsed cluster, redirect from its collapsed node
        //console.log(`Redirecting edge from ${sourceCluster}_collapsed to ${collapsedNodeId}`);
        graph.removeEdge(edge.v, edge.w);
        graph.setEdge(`${sourceCluster}_collapsed`, collapsedNodeId, graph.edge(edge));
      } else {
        // Source node is not in a collapsed cluster
        //console.log(`Redirecting edge from ${sourceNode} to ${collapsedNodeId}`);
        graph.removeEdge(edge.v, edge.w);
        graph.setEdge(sourceNode, collapsedNodeId, graph.edge(edge));
      }
    }
  });
}

function collectAllNodes(clusterId, collectedNodes = new Set()) {
  const nodes = graph.children(clusterId);

  nodes.forEach(nodeId => {
    if (!collectedNodes.has(nodeId)) {
      collectedNodes.add(nodeId);
      if (graph.children(nodeId).length > 0) {
        // Recursively collect nodes from subclusters
        collectAllNodes(nodeId, collectedNodes);
      }
    }
  });
  return collectedNodes;
}
  // add event listeners and Call initialize 
      document.getElementById('update-dot-src').addEventListener('click', () => {
     initialize();
    });
	document.getElementById('generate-graph').addEventListener('click', handleFileLoad);
	//eventlistener for collapsing file based section
	document.getElementById('toggle-file-based-graph').addEventListener('click', function() {
  const container = document.getElementById('file-based-graph-container');
  const button = this;
  if (container.style.display === 'none') {
    container.style.display = 'flex';
    button.textContent = 'File Based Graph â–²';
  } else {
    container.style.display = 'none';
    button.textContent = 'File Based Graph â–¼';
  }
});
  initialize();
</script>
</body>
</html>
